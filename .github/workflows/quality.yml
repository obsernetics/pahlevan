name: Advanced Code Quality

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 5 * * *'  # Daily at 5 AM
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: "1.24"

jobs:
  static-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0  # Full history for better analysis

    - name: Setup Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install eBPF dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y clang llvm libbpf-dev linux-headers-generic

    - name: Generate eBPF bindings
      run: go generate ./...

    - name: Install advanced analysis tools
      run: |
        # Install staticcheck
        go install honnef.co/go/tools/cmd/staticcheck@latest

        # Install golangci-lint with all linters
        curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.55.2

        # Install gosec for security analysis
        go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest

        # Install govulncheck
        go install golang.org/x/vuln/cmd/govulncheck@latest

        # Install cyclonedx for SBOM generation
        go install github.com/CycloneDX/cyclonedx-gomod/cmd/cyclonedx-gomod@latest

        # Install ineffassign
        go install github.com/gordonklaus/ineffassign@latest

        # Install misspell
        go install github.com/client9/misspell/cmd/misspell@latest

        # Install gocyclo for complexity analysis
        go install github.com/fzipp/gocyclo/cmd/gocyclo@latest

    - name: Run comprehensive static analysis
      run: |
        echo "=== Comprehensive Static Analysis Report ===" > static-analysis-report.txt
        echo "Generated: $(date -u)" >> static-analysis-report.txt
        echo "" >> static-analysis-report.txt

        # Run staticcheck
        echo "## Staticcheck Results" >> static-analysis-report.txt
        staticcheck ./... >> static-analysis-report.txt 2>&1 || echo "Staticcheck completed with findings"
        echo "" >> static-analysis-report.txt

        # Run golangci-lint with comprehensive config
        echo "## GolangCI-Lint Results" >> static-analysis-report.txt
        golangci-lint run --enable-all --timeout=10m --issues-exit-code=0 ./... >> static-analysis-report.txt 2>&1 || echo "GolangCI-Lint completed"
        echo "" >> static-analysis-report.txt

        # Run gosec for security analysis
        echo "## Security Analysis (gosec)" >> static-analysis-report.txt
        gosec -fmt=text -out=gosec-report.txt ./... || echo "Gosec completed with findings"
        cat gosec-report.txt >> static-analysis-report.txt 2>/dev/null || echo "No gosec report found"
        echo "" >> static-analysis-report.txt

        # Check for inefficient assignments
        echo "## Inefficient Assignments" >> static-analysis-report.txt
        ineffassign ./... >> static-analysis-report.txt 2>&1 || echo "No inefficient assignments found"
        echo "" >> static-analysis-report.txt

        # Check for misspelled words
        echo "## Spelling Check" >> static-analysis-report.txt
        find . -name "*.go" -not -path "./vendor/*" | xargs misspell >> static-analysis-report.txt 2>&1 || echo "No misspellings found"
        echo "" >> static-analysis-report.txt

        # Cyclomatic complexity analysis
        echo "## Cyclomatic Complexity (>10)" >> static-analysis-report.txt
        gocyclo -over 10 . >> static-analysis-report.txt 2>&1 || echo "No high complexity functions found"
        echo "" >> static-analysis-report.txt

    - name: Code metrics analysis
      run: |
        echo "=== Code Metrics Analysis ===" > code-metrics.txt
        echo "" >> code-metrics.txt

        # Lines of code statistics
        echo "## Lines of Code Statistics" >> code-metrics.txt
        find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*" -not -name "*_test.go" | xargs wc -l | sort -nr | head -20 >> code-metrics.txt
        echo "" >> code-metrics.txt

        # Test coverage statistics
        echo "## Test Coverage Analysis" >> code-metrics.txt
        total_go_files=$(find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*" -not -name "*_test.go" | wc -l)
        test_files=$(find . -name "*_test.go" -not -path "./vendor/*" | wc -l)
        echo "Production Go files: $total_go_files" >> code-metrics.txt
        echo "Test files: $test_files" >> code-metrics.txt
        echo "Test ratio: $(echo "scale=2; $test_files / $total_go_files * 100" | bc -l 2>/dev/null || echo "N/A")%" >> code-metrics.txt
        echo "" >> code-metrics.txt

        # Package dependencies
        echo "## Package Dependencies" >> code-metrics.txt
        go list -m all | wc -l >> code-metrics.txt
        echo "Direct dependencies:" >> code-metrics.txt
        go list -m -f '{{if not .Indirect}}{{.Path}} {{.Version}}{{end}}' all | head -20 >> code-metrics.txt
        echo "" >> code-metrics.txt

        # Function complexity distribution
        echo "## Function Complexity Distribution" >> code-metrics.txt
        gocyclo . | awk '{print $1}' | sort -n | uniq -c | tail -10 >> code-metrics.txt 2>/dev/null || echo "Complexity analysis not available"

    - name: Generate SBOM (Software Bill of Materials)
      run: |
        echo "Generating Software Bill of Materials..."
        cyclonedx-gomod mod -json -output sbom.json . || echo "SBOM generation completed with warnings"

        # Create human-readable SBOM summary
        if [ -f sbom.json ]; then
          echo "## Software Bill of Materials Summary" > sbom-summary.txt
          echo "Generated: $(date -u)" >> sbom-summary.txt
          echo "" >> sbom-summary.txt

          # Extract component count
          components=$(jq '.components | length' sbom.json 2>/dev/null || echo "0")
          echo "Total Components: $components" >> sbom-summary.txt

          # List top dependencies
          echo "" >> sbom-summary.txt
          echo "## Key Dependencies:" >> sbom-summary.txt
          jq -r '.components[] | select(.type == "library") | "\(.name) - \(.version // "latest")"' sbom.json 2>/dev/null | head -20 >> sbom-summary.txt || echo "SBOM parsing failed"
        fi

    - name: Advanced security scanning
      run: |
        echo "=== Advanced Security Analysis ===" > security-analysis.txt

        # Run govulncheck
        echo "## Vulnerability Check" >> security-analysis.txt
        govulncheck ./... >> security-analysis.txt 2>&1 || echo "Vulnerability check completed"
        echo "" >> security-analysis.txt

        # Check for hardcoded secrets patterns
        echo "## Hardcoded Secrets Detection" >> security-analysis.txt
        secret_patterns=(
          "password.*=.*['\"][^'\"]{8,}"
          "api.*key.*=.*['\"][^'\"]{20,}"
          "token.*=.*['\"][^'\"]{20,}"
          "secret.*=.*['\"][^'\"]{16,}"
          "-----BEGIN.*PRIVATE.*KEY-----"
        )

        for pattern in "${secret_patterns[@]}"; do
          echo "Checking pattern: $pattern" >> security-analysis.txt
          grep -r -n -E "$pattern" . --include="*.go" --exclude-dir=vendor --exclude-dir=.git >> security-analysis.txt 2>/dev/null || echo "No matches found for pattern" >> security-analysis.txt
        done
        echo "" >> security-analysis.txt

        # Check for unsafe operations
        echo "## Unsafe Operations Check" >> security-analysis.txt
        grep -r -n "unsafe\." . --include="*.go" --exclude-dir=vendor >> security-analysis.txt 2>/dev/null || echo "No unsafe operations found" >> security-analysis.txt

    - name: Documentation quality check
      run: |
        echo "=== Documentation Quality Analysis ===" > docs-analysis.txt

        # Check for undocumented exported functions
        echo "## Undocumented Exported Functions" >> docs-analysis.txt
        find . -name "*.go" -not -path "./vendor/*" -not -name "*_test.go" -exec grep -l "^func [A-Z]" {} \; | while read -r file; do
          echo "Checking $file..." >> docs-analysis.txt
          awk '/^func [A-Z]/ {
            func_line = NR;
            func_name = $2;
            gsub(/\(.*$/, "", func_name);
            getline prev < (FILENAME);
            if (prev !~ /^\/\/.*/ || NR == 1) {
              print FILENAME ":" func_line ": Missing documentation for " func_name
            }
          }' "$file" >> docs-analysis.txt 2>/dev/null || true
        done

        # Check README quality
        echo "" >> docs-analysis.txt
        echo "## README Quality Check" >> docs-analysis.txt
        if [ -f README.md ]; then
          readme_lines=$(wc -l < README.md)
          echo "README.md has $readme_lines lines" >> docs-analysis.txt

          # Check for essential sections
          essential_sections=("Installation" "Usage" "API" "Contributing" "License")
          for section in "${essential_sections[@]}"; do
            if grep -qi "$section" README.md; then
              echo "✅ $section section found" >> docs-analysis.txt
            else
              echo "❌ $section section missing" >> docs-analysis.txt
            fi
          done
        else
          echo "❌ README.md not found" >> docs-analysis.txt
        fi

    - name: Performance impact analysis
      run: |
        echo "=== Performance Impact Analysis ===" > performance-analysis.txt

        # Analyze binary sizes
        echo "## Binary Size Analysis" >> performance-analysis.txt
        go build -o bin/operator-unoptimized ./cmd/operator
        go build -ldflags="-s -w" -o bin/operator-optimized ./cmd/operator

        unopt_size=$(stat -c%s bin/operator-unoptimized 2>/dev/null || echo "0")
        opt_size=$(stat -c%s bin/operator-optimized 2>/dev/null || echo "0")

        echo "Unoptimized binary: $((unopt_size / 1024 / 1024)) MB" >> performance-analysis.txt
        echo "Optimized binary: $((opt_size / 1024 / 1024)) MB" >> performance-analysis.txt
        if [ "$unopt_size" -gt 0 ]; then
          savings=$((100 - (opt_size * 100 / unopt_size)))
          echo "Size reduction: $savings%" >> performance-analysis.txt
        fi

        # Memory allocation analysis
        echo "" >> performance-analysis.txt
        echo "## Memory Allocation Hotspots" >> performance-analysis.txt
        go test -run=^$ -bench=. -benchmem ./... 2>/dev/null | grep -E "(Benchmark|B/op|allocs/op)" | head -20 >> performance-analysis.txt || echo "No benchmark data available"

    - name: Generate comprehensive quality report
      run: |
        cat > quality-dashboard.md << 'EOF'
        # Code Quality Dashboard

        **Generated:** $(date -u)
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}

        ## Quality Metrics Summary

        ### Static Analysis
        - **Staticcheck**: $(grep -c "staticcheck" static-analysis-report.txt 2>/dev/null || echo "0") issues
        - **Security Issues**: $(grep -c "G[0-9]" static-analysis-report.txt 2>/dev/null || echo "0") findings
        - **Spelling Errors**: $(grep -c "misspell" static-analysis-report.txt 2>/dev/null || echo "0") issues

        ### Code Metrics
        - **Total Go Files**: $(find . -name "*.go" -not -path "./vendor/*" | wc -l)
        - **Test Files**: $(find . -name "*_test.go" | wc -l)
        - **Lines of Code**: $(find . -name "*.go" -not -path "./vendor/*" | xargs wc -l | tail -1 | awk '{print $1}')

        ### Security Status
        - **Vulnerability Scan**: $([ -f security-analysis.txt ] && echo "✅ Completed" || echo "❌ Failed")
        - **SBOM Generated**: $([ -f sbom.json ] && echo "✅ Available" || echo "❌ Missing")
        - **Secrets Detection**: $([ -f security-analysis.txt ] && echo "✅ Scanned" || echo "❌ Skipped")

        ## Detailed Reports

        See artifacts for complete analysis reports:
        - Static Analysis Report
        - Security Analysis Report
        - Code Metrics Report
        - Documentation Analysis
        - Performance Impact Analysis

        EOF

    - name: Upload quality reports
      uses: actions/upload-artifact@v4
      with:
        name: quality-reports-${{ github.run_number }}
        path: |
          quality-dashboard.md
          static-analysis-report.txt
          code-metrics.txt
          security-analysis.txt
          docs-analysis.txt
          performance-analysis.txt
          sbom.json
          sbom-summary.txt

    - name: Comment PR with quality summary
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v8
      with:
        script: |
          const fs = require('fs');

          if (fs.existsSync('quality-dashboard.md')) {
            const dashboard = fs.readFileSync('quality-dashboard.md', 'utf8');

            // Find existing quality comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.data.find(comment =>
              comment.user.type === 'Bot' && comment.body.includes('Code Quality Dashboard')
            );

            const commentBody = `## 📊 ${dashboard}

            ---
            *This quality report is automatically updated with each push.*`;

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
          }

  dependency-analysis:
    name: Dependency Analysis
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Setup Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Analyze dependencies
      run: |
        echo "=== Dependency Analysis ===" > dependency-analysis.txt

        # Direct vs indirect dependencies
        echo "## Dependency Breakdown" >> dependency-analysis.txt
        direct_deps=$(go list -m -f '{{if not .Indirect}}{{.Path}}{{end}}' all | grep -v "^$" | wc -l)
        indirect_deps=$(go list -m -f '{{if .Indirect}}{{.Path}}{{end}}' all | grep -v "^$" | wc -l)

        echo "Direct dependencies: $direct_deps" >> dependency-analysis.txt
        echo "Indirect dependencies: $indirect_deps" >> dependency-analysis.txt
        echo "Total dependencies: $((direct_deps + indirect_deps))" >> dependency-analysis.txt
        echo "" >> dependency-analysis.txt

        # License analysis
        echo "## License Analysis" >> dependency-analysis.txt
        go list -m -json all | jq -r 'select(.Path != null) | .Path' | while read -r dep; do
          license_info=$(go list -m -json "$dep" 2>/dev/null | jq -r '.Dir' 2>/dev/null || echo "")
          if [ -n "$license_info" ] && [ -d "$license_info" ]; then
            license_file=$(find "$license_info" -maxdepth 1 -iname "license*" -o -iname "copying*" | head -1)
            if [ -n "$license_file" ]; then
              license_type=$(head -5 "$license_file" 2>/dev/null | grep -i -E "(apache|mit|bsd|gpl|mozilla)" | head -1 || echo "Unknown")
              echo "$dep: $license_type" >> dependency-analysis.txt
            fi
          fi
        done | head -20 >> dependency-analysis.txt

        # Outdated dependencies check
        echo "" >> dependency-analysis.txt
        echo "## Dependency Updates Available" >> dependency-analysis.txt
        go list -u -m all 2>/dev/null | grep -E "\[.*\]" >> dependency-analysis.txt || echo "All dependencies up to date"

    - name: Upload dependency analysis
      uses: actions/upload-artifact@v4
      with:
        name: dependency-analysis-${{ github.run_number }}
        path: dependency-analysis.txt