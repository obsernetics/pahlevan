name: Monitoring & Alerting

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes
  workflow_dispatch:

env:
  GO_VERSION: "1.24"

jobs:
  health-checks:
    name: System Health Monitoring
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Setup Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install monitoring tools
      run: |
        # Install curl for health checks
        sudo apt-get update && sudo apt-get install -y curl jq

        # Install GitHub CLI for issue management
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
        sudo apt-get update && sudo apt-get install -y gh

    - name: Check repository health
      id: repo_health
      run: |
        echo "=== Repository Health Check ==="

        # Check for security alerts
        echo "Checking security alerts..."
        security_alerts=$(gh api repos/${{ github.repository }}/security-advisories --jq '. | length' 2>/dev/null || echo "0")
        echo "security_alerts=$security_alerts" >> $GITHUB_OUTPUT

        # Check for open critical issues
        echo "Checking critical issues..."
        critical_issues=$(gh api repos/${{ github.repository }}/issues --jq '[.[] | select(.labels[].name == "critical")] | length' 2>/dev/null || echo "0")
        echo "critical_issues=$critical_issues" >> $GITHUB_OUTPUT

        # Check workflow failures
        echo "Checking recent workflow failures..."
        failed_runs=$(gh api repos/${{ github.repository }}/actions/runs --jq '[.workflow_runs[] | select(.conclusion == "failure" and .created_at > (now - 86400 | todate))] | length' 2>/dev/null || echo "0")
        echo "failed_runs=$failed_runs" >> $GITHUB_OUTPUT

        # Check dependency vulnerabilities
        echo "Checking dependency alerts..."
        vuln_alerts=$(gh api repos/${{ github.repository }}/dependabot/alerts --jq '[.[] | select(.state == "open")] | length' 2>/dev/null || echo "0")
        echo "vuln_alerts=$vuln_alerts" >> $GITHUB_OUTPUT

        echo "=== Health Check Results ==="
        echo "Security Alerts: $security_alerts"
        echo "Critical Issues: $critical_issues"
        echo "Recent Failed Runs: $failed_runs"
        echo "Vulnerability Alerts: $vuln_alerts"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Code quality metrics
      run: |
        echo "=== Code Quality Metrics ==="

        # Count lines of code
        find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*" | xargs wc -l | tail -1

        # Count test coverage files
        test_files=$(find . -name "*_test.go" -not -path "./vendor/*" | wc -l)
        echo "Test files: $test_files"

        # Check for TODO/FIXME comments
        todos=$(grep -r -n "TODO\|FIXME\|HACK" . --include="*.go" --exclude-dir=vendor --exclude-dir=.git | wc -l)
        echo "TODO/FIXME comments: $todos"

        # Check gofmt compliance
        unformatted=$(gofmt -l . 2>/dev/null | grep -v vendor | wc -l)
        echo "Unformatted Go files: $unformatted"

    - name: Performance metrics collection
      run: |
        echo "=== Performance Metrics ==="

        # Build time measurement
        start_time=$(date +%s)
        go build -o bin/test-build ./cmd/operator > /dev/null 2>&1
        build_time=$(($(date +%s) - start_time))
        echo "Build time: ${build_time}s"

        # Binary size
        if [ -f bin/test-build ]; then
          binary_size=$(stat -c%s bin/test-build)
          echo "Binary size: $((binary_size / 1024 / 1024)) MB"
        fi

        # Dependency count
        dep_count=$(go list -m all | wc -l)
        echo "Dependencies: $dep_count"

    - name: Generate monitoring report
      run: |
        cat > monitoring-report.md << EOF
        # System Monitoring Report

        **Generated:** $(date -u)
        **Repository:** ${{ github.repository }}
        **Commit:** ${{ github.sha }}

        ## Health Status

        | Metric | Value | Status |
        |--------|--------|--------|
        | Security Alerts | ${{ steps.repo_health.outputs.security_alerts }} | $( [ "${{ steps.repo_health.outputs.security_alerts }}" -eq "0" ] && echo "🟢 Good" || echo "🔴 Action Needed" ) |
        | Critical Issues | ${{ steps.repo_health.outputs.critical_issues }} | $( [ "${{ steps.repo_health.outputs.critical_issues }}" -eq "0" ] && echo "🟢 Good" || echo "🔴 Action Needed" ) |
        | Recent Failures | ${{ steps.repo_health.outputs.failed_runs }} | $( [ "${{ steps.repo_health.outputs.failed_runs }}" -lt "3" ] && echo "🟢 Good" || echo "🟡 Monitor" ) |
        | Vulnerability Alerts | ${{ steps.repo_health.outputs.vuln_alerts }} | $( [ "${{ steps.repo_health.outputs.vuln_alerts }}" -eq "0" ] && echo "🟢 Good" || echo "🔴 Action Needed" ) |

        ## Recommendations

        EOF

        # Add recommendations based on metrics
        if [ "${{ steps.repo_health.outputs.security_alerts }}" -gt "0" ]; then
          echo "- 🔴 **Security Alert**: Review and address security advisories" >> monitoring-report.md
        fi

        if [ "${{ steps.repo_health.outputs.critical_issues }}" -gt "0" ]; then
          echo "- 🔴 **Critical Issues**: Address critical issues immediately" >> monitoring-report.md
        fi

        if [ "${{ steps.repo_health.outputs.failed_runs }}" -gt "2" ]; then
          echo "- 🟡 **Workflow Failures**: Investigate recent workflow failures" >> monitoring-report.md
        fi

        if [ "${{ steps.repo_health.outputs.vuln_alerts }}" -gt "0" ]; then
          echo "- 🔴 **Dependencies**: Update vulnerable dependencies" >> monitoring-report.md
        fi

        echo "- ✅ **Regular Monitoring**: Continue monitoring system health" >> monitoring-report.md

    - name: Alert on critical issues
      if: steps.repo_health.outputs.security_alerts > 0 || steps.repo_health.outputs.critical_issues > 0
      run: |
        echo "🚨 CRITICAL ALERT: Immediate attention required!"
        echo "Security Alerts: ${{ steps.repo_health.outputs.security_alerts }}"
        echo "Critical Issues: ${{ steps.repo_health.outputs.critical_issues }}"

        # Create monitoring issue if critical problems detected
        gh issue create \
          --title "🚨 Critical System Alert - $(date +%Y-%m-%d)" \
          --body "$(cat monitoring-report.md)" \
          --label "critical,monitoring,automated" \
          --assignee "@me" || echo "Could not create issue"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload monitoring report
      uses: actions/upload-artifact@v4
      with:
        name: monitoring-report-${{ github.run_number }}
        path: monitoring-report.md

  infrastructure-monitoring:
    name: Infrastructure Health
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Monitor container registry
      run: |
        echo "=== Container Registry Monitoring ==="

        # Check if latest image exists and is recent
        image_info=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          "https://ghcr.io/v2/${{ github.repository_owner }}/pahlevan/manifests/latest" || echo "Image not found")

        if echo "$image_info" | grep -q "errors"; then
          echo "⚠️ Warning: Latest container image not found or inaccessible"
        else
          echo "✅ Container image is accessible"
        fi

    - name: Check GitHub Pages
      run: |
        echo "=== Documentation Site Monitoring ==="

        # Check if documentation site is accessible
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/" || echo "000")

        if [ "$status_code" -eq "200" ]; then
          echo "✅ Documentation site is accessible"
        else
          echo "⚠️ Warning: Documentation site returned status code: $status_code"
        fi

    - name: Monitor workflow performance
      run: |
        echo "=== Workflow Performance Monitoring ==="

        # Get average workflow duration for main workflows
        workflows=("ci.yml" "security.yml" "build.yml" "e2e.yml")

        for workflow in "${workflows[@]}"; do
          echo "Checking $workflow performance..."

          # Get recent run durations (simplified check)
          recent_runs=$(gh api repos/${{ github.repository }}/actions/workflows/$workflow/runs --jq '.workflow_runs[0:5] | map(select(.conclusion == "success")) | map(.updated_at as $end | .created_at as $start | (($end | fromdateiso8601) - ($start | fromdateiso8601))) | add / length' 2>/dev/null || echo "0")

          echo "$workflow average duration: ${recent_runs}s"
        done
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  auto-maintenance:
    name: Automated Maintenance
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Close stale issues
      run: |
        echo "=== Automated Issue Maintenance ==="

        # Close stale issues that haven't been updated in 30 days
        stale_issues=$(gh api repos/${{ github.repository }}/issues --jq '[.[] | select(.updated_at < (now - 2592000 | todate) and .state == "open" and (.labels | map(.name) | contains(["stale"]) | not))]')

        echo "$stale_issues" | jq -r '.[] | .number' | while read -r issue_num; do
          if [ -n "$issue_num" ]; then
            echo "Marking issue #$issue_num as stale"
            gh issue comment "$issue_num" --body "This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs within 7 days."
            gh issue edit "$issue_num" --add-label "stale"
          fi
        done

        # Close issues marked as stale for more than 7 days
        very_stale_issues=$(gh api repos/${{ github.repository }}/issues --jq '[.[] | select(.updated_at < (now - 604800 | todate) and .state == "open" and (.labels | map(.name) | contains(["stale"])))]')

        echo "$very_stale_issues" | jq -r '.[] | .number' | while read -r issue_num; do
          if [ -n "$issue_num" ]; then
            echo "Closing stale issue #$issue_num"
            gh issue close "$issue_num" --comment "Automatically closing this stale issue. Please reopen if this issue is still relevant."
          fi
        done
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update project metrics
      run: |
        echo "=== Project Metrics Update ==="

        # Count and update project statistics
        total_commits=$(git rev-list --count HEAD)
        total_files=$(find . -name "*.go" -not -path "./vendor/*" | wc -l)
        total_lines=$(find . -name "*.go" -not -path "./vendor/*" | xargs wc -l | tail -1 | awk '{print $1}')

        echo "Project Statistics:"
        echo "- Total Commits: $total_commits"
        echo "- Go Files: $total_files"
        echo "- Lines of Code: $total_lines"

        # Could be extended to update README badges or create metrics files