/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package policies

import (
	"context"
	"fmt"
	"hash/fnv"
	"strconv"
	"sync"
	"time"

	"github.com/obsernetics/pahlevan/internal/learner"
	policyv1alpha1 "github.com/obsernetics/pahlevan/pkg/apis/policy/v1alpha1"
	"github.com/obsernetics/pahlevan/pkg/ebpf"
	"go.opentelemetry.io/otel/metric"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// EnforcementEngine implements adaptive policy generation and enforcement
type EnforcementEngine struct {
	mu                 sync.RWMutex
	ebpfManager        *ebpf.Manager
	learner            *learner.SyscallLearner
	containerPolicies  map[string]*ContainerPolicyState
	globalConfig       *GlobalEnforcementConfig
	enforcementQueue   chan *EnforcementAction
	selfHealingEnabled bool
	stopCh             chan struct{}

	// Metrics
	policyGenerationCounter  metric.Int64Counter
	enforcementActionCounter metric.Int64Counter
	policyViolationCounter   metric.Int64Counter
	selfHealingCounter       metric.Int64Counter
}

// ContainerPolicyState tracks the policy state for a container
type ContainerPolicyState struct {
	ContainerID      string
	WorkloadRef      learner.WorkloadReference
	PahlevanPolicy   *policyv1alpha1.PahlevanPolicy
	GeneratedPolicy  *GeneratedPolicy
	EnforcementMode  EnforcementMode
	LastPolicyUpdate time.Time
	ViolationHistory []PolicyViolation
	SelfHealingState *SelfHealingState
	LifecyclePhase   WorkloadLifecyclePhase
	Statistics       EnforcementStatistics
}

// GeneratedPolicy represents the complete generated policy for a container
type GeneratedPolicy struct {
	ContainerID    string
	GeneratedAt    time.Time
	BasedOnProfile *learner.LearningProfile

	// Syscall policy
	SyscallPolicy *SyscallEnforcementPolicy

	// Network policy
	NetworkPolicy *NetworkEnforcementPolicy

	// File access policy
	FilePolicy *FileEnforcementPolicy

	// Policy metadata
	Quality       PolicyQuality
	Confidence    float64
	AutoGenerated bool
	Version       int
}

// SyscallEnforcementPolicy defines syscall enforcement rules
type SyscallEnforcementPolicy struct {
	AllowedSyscalls      map[uint64]*SyscallRule
	DeniedSyscalls       map[uint64]*SyscallRule
	DefaultAction        PolicyAction
	ContextRules         map[string]*ContextRule
	ArgumentValidation   map[uint64]*ArgumentRule
	ReturnCodeValidation map[uint64]*ReturnCodeRule
}

// NetworkEnforcementPolicy defines network enforcement rules
type NetworkEnforcementPolicy struct {
	EgressRules          []*NetworkRule
	IngressRules         []*NetworkRule
	DefaultEgressAction  PolicyAction
	DefaultIngressAction PolicyAction
	FlowLimits           *FlowLimits
	BandwidthLimits      *BandwidthLimits
}

// FileEnforcementPolicy defines file access enforcement rules
type FileEnforcementPolicy struct {
	AllowedPaths     map[string]*FileRule
	DeniedPaths      map[string]*FileRule
	DefaultAction    PolicyAction
	PathPatterns     []*PathPattern
	AccessModeRules  map[string]*AccessModeRule
	SizeRestrictions map[string]*SizeRestriction
}

// Policy rules and constraints
type SyscallRule struct {
	SyscallNr       uint64
	Action          PolicyAction
	Conditions      []RuleCondition
	RateLimit       *RateLimit
	Criticality     learner.CriticalityLevel
	AllowedContexts []string
}

type NetworkRule struct {
	Protocol       string
	Direction      string
	RemoteEndpoint *EndpointRule
	LocalEndpoint  *EndpointRule
	Action         PolicyAction
	RateLimit      *RateLimit
	Conditions     []RuleCondition
}

type FileRule struct {
	PathPattern string
	AccessModes []string
	Action      PolicyAction
	Conditions  []RuleCondition
	MaxSize     *int64
	FileTypes   []string
}

type ContextRule struct {
	ProcessName     string
	UserID          *uint32
	GroupID         *uint32
	AllowedSyscalls []uint64
}

type ArgumentRule struct {
	SyscallNr       uint64
	ArgumentIndex   int
	ValidationRules []ArgumentValidation
}

type ReturnCodeRule struct {
	SyscallNr          uint64
	AllowedReturnCodes []int64
	FailureAction      PolicyAction
}

type EndpointRule struct {
	IPRange   string
	PortRange *PortRange
	Hostnames []string
}

type PathPattern struct {
	Pattern   string
	Action    PolicyAction
	Recursive bool
}

type AccessModeRule struct {
	Mode   string
	Paths  []string
	Action PolicyAction
}

type SizeRestriction struct {
	PathPattern string
	MaxSize     int64
	Action      PolicyAction
}

type RuleCondition struct {
	Type     ConditionType
	Operator ConditionOperator
	Value    string
	Negated  bool
}

type ArgumentValidation struct {
	Type          ArgumentType
	MinValue      *int64
	MaxValue      *int64
	Pattern       string
	AllowedValues []string
}

type RateLimit struct {
	MaxPerSecond int32
	MaxPerMinute int32
	MaxPerHour   int32
	BurstLimit   int32
}

type FlowLimits struct {
	MaxConcurrentConnections int32
	MaxConnectionsPerSecond  int32
	MaxConnectionsPerMinute  int32
}

type BandwidthLimits struct {
	MaxBytesPerSecond int64
	MaxBytesPerMinute int64
}

type PortRange struct {
	Start int32
	End   int32
}

// Enums and types
type EnforcementMode string

const (
	EnforcementModeOff        EnforcementMode = "Off"
	EnforcementModeLearning   EnforcementMode = "Learning"
	EnforcementModeMonitoring EnforcementMode = "Monitoring"
	EnforcementModeBlocking   EnforcementMode = "Blocking"
)

type PolicyAction string

const (
	PolicyActionAllow PolicyAction = "Allow"
	PolicyActionDeny  PolicyAction = "Deny"
	PolicyActionAlert PolicyAction = "Alert"
	PolicyActionAudit PolicyAction = "Audit"
	PolicyActionKill  PolicyAction = "Kill"
)

type WorkloadLifecyclePhase string

const (
	PhaseInitializing WorkloadLifecyclePhase = "Initializing"
	PhaseStarting     WorkloadLifecyclePhase = "Starting"
	PhaseRunning      WorkloadLifecyclePhase = "Running"
	PhaseSteady       WorkloadLifecyclePhase = "Steady"
	PhaseTerminating  WorkloadLifecyclePhase = "Terminating"
)

type ConditionType string

const (
	ConditionTypeTime      ConditionType = "Time"
	ConditionTypeFrequency ConditionType = "Frequency"
	ConditionTypeProcess   ConditionType = "Process"
	ConditionTypeUser      ConditionType = "User"
	ConditionTypeNetwork   ConditionType = "Network"
)

type ConditionOperator string

const (
	ConditionOperatorEquals    ConditionOperator = "Equals"
	ConditionOperatorNotEquals ConditionOperator = "NotEquals"
	ConditionOperatorGreater   ConditionOperator = "Greater"
	ConditionOperatorLess      ConditionOperator = "Less"
	ConditionOperatorContains  ConditionOperator = "Contains"
	ConditionOperatorMatches   ConditionOperator = "Matches"
)

type ArgumentType string

const (
	ArgumentTypeInteger ArgumentType = "Integer"
	ArgumentTypeString  ArgumentType = "String"
	ArgumentTypePointer ArgumentType = "Pointer"
	ArgumentTypePath    ArgumentType = "Path"
)

type PolicyQuality struct {
	Score           float64
	Completeness    float64
	Accuracy        float64
	Performance     float64
	Security        float64
	Maintainability float64
}

type PolicyViolation struct {
	Timestamp     time.Time
	ViolationType ViolationType
	Details       ViolationDetails
	Action        PolicyAction
	Severity      ViolationSeverity
	Context       ViolationContext
}

type ViolationType string

const (
	ViolationTypeSyscall ViolationType = "Syscall"
	ViolationTypeNetwork ViolationType = "Network"
	ViolationTypeFile    ViolationType = "File"
)

type ViolationSeverity string

const (
	ViolationSeverityLow      ViolationSeverity = "Low"
	ViolationSeverityMedium   ViolationSeverity = "Medium"
	ViolationSeverityHigh     ViolationSeverity = "High"
	ViolationSeverityCritical ViolationSeverity = "Critical"
)

type ViolationDetails struct {
	Resource        string
	AttemptedAction string
	ExpectedAction  string
	ActualResult    string
}

type ViolationContext struct {
	ProcessName string
	ProcessID   uint32
	UserID      uint32
	GroupID     uint32
	Timestamp   time.Time
}

type SelfHealingState struct {
	Enabled           bool
	ViolationCount    int32
	LastViolationTime time.Time
	RollbackThreshold int32
	RollbackWindow    time.Duration
	LastRollbackTime  time.Time
	RollbackCount     int32
	CurrentPolicy     *GeneratedPolicy
	PreviousPolicy    *GeneratedPolicy
	RecoveryStrategy  RecoveryStrategy
}

type RecoveryStrategy string

const (
	RecoveryStrategyRollback    RecoveryStrategy = "Rollback"
	RecoveryStrategyRelax       RecoveryStrategy = "Relax"
	RecoveryStrategyMaintenance RecoveryStrategy = "Maintenance"
	RecoveryStrategyDisable     RecoveryStrategy = "Disable"
)

type EnforcementStatistics struct {
	PolicyGenerationCount  int64
	EnforcementActionCount int64
	ViolationCount         int64
	SelfHealingActionCount int64
	LastViolationTime      time.Time
	AverageResponseTime    time.Duration
	SuccessRate            float64
}

type EnforcementAction struct {
	Type        ActionType
	ContainerID string
	Policy      *GeneratedPolicy
	Violation   *PolicyViolation
	Timestamp   time.Time
	Priority    ActionPriority
}

type ActionType string

const (
	ActionTypeGeneratePolicy ActionType = "GeneratePolicy"
	ActionTypeUpdatePolicy   ActionType = "UpdatePolicy"
	ActionTypeEnforcePolicy  ActionType = "EnforcePolicy"
	ActionTypeViolation      ActionType = "Violation"
	ActionTypeSelfHeal       ActionType = "SelfHeal"
)

type ActionPriority string

const (
	ActionPriorityLow      ActionPriority = "Low"
	ActionPriorityMedium   ActionPriority = "Medium"
	ActionPriorityHigh     ActionPriority = "High"
	ActionPriorityCritical ActionPriority = "Critical"
)

type GlobalEnforcementConfig struct {
	DefaultEnforcementMode   EnforcementMode
	PolicyGenerationInterval time.Duration
	ViolationThreshold       int32
	SelfHealingEnabled       bool
	SelfHealingThreshold     int32
	SelfHealingWindow        time.Duration
	MetricsEnabled           bool
	AuditEnabled             bool
}

func NewEnforcementEngine(ebpfManager *ebpf.Manager, learner *learner.SyscallLearner) *EnforcementEngine {
	return &EnforcementEngine{
		ebpfManager:       ebpfManager,
		learner:           learner,
		containerPolicies: make(map[string]*ContainerPolicyState),
		enforcementQueue:  make(chan *EnforcementAction, 1000),
		stopCh:            make(chan struct{}),
		globalConfig: &GlobalEnforcementConfig{
			DefaultEnforcementMode:   EnforcementModeMonitoring,
			PolicyGenerationInterval: 5 * time.Minute,
			ViolationThreshold:       10,
			SelfHealingEnabled:       true,
			SelfHealingThreshold:     5,
			SelfHealingWindow:        10 * time.Minute,
			MetricsEnabled:           true,
			AuditEnabled:             true,
		},
	}
}

func (ee *EnforcementEngine) Start(ctx context.Context) error {
	log.Log.Info("Starting enforcement engine")

	// Start background goroutines
	go ee.enforcementWorker(ctx)
	go ee.policyGenerationWorker(ctx)
	go ee.selfHealingWorker(ctx)
	go ee.statisticsWorker(ctx)

	return nil
}

func (ee *EnforcementEngine) Stop() {
	close(ee.stopCh)
}

func (ee *EnforcementEngine) RegisterContainer(
	containerID string,
	workloadRef learner.WorkloadReference,
	policy *policyv1alpha1.PahlevanPolicy,
) error {
	ee.mu.Lock()
	defer ee.mu.Unlock()

	state := &ContainerPolicyState{
		ContainerID:      containerID,
		WorkloadRef:      workloadRef,
		PahlevanPolicy:   policy,
		EnforcementMode:  ee.determineEnforcementMode(policy),
		LastPolicyUpdate: time.Now(),
		ViolationHistory: make([]PolicyViolation, 0),
		LifecyclePhase:   PhaseInitializing,
		Statistics:       EnforcementStatistics{},
	}

	// Initialize self-healing if enabled
	if policy.Spec.SelfHealing.Enabled {
		state.SelfHealingState = &SelfHealingState{
			Enabled:           true,
			RollbackThreshold: policy.Spec.SelfHealing.RollbackThreshold,
			RollbackWindow:    policy.Spec.SelfHealing.RollbackWindow.Duration,
			RecoveryStrategy:  RecoveryStrategy(policy.Spec.SelfHealing.RecoveryStrategy),
		}
	}

	ee.containerPolicies[containerID] = state

	// Queue initial policy generation
	ee.queueEnforcementAction(&EnforcementAction{
		Type:        ActionTypeGeneratePolicy,
		ContainerID: containerID,
		Timestamp:   time.Now(),
		Priority:    ActionPriorityMedium,
	})

	return nil
}

func (ee *EnforcementEngine) GeneratePolicy(containerID string) (*GeneratedPolicy, error) {
	ee.mu.RLock()
	state, exists := ee.containerPolicies[containerID]
	ee.mu.RUnlock()

	if !exists {
		return nil, fmt.Errorf("container not found: %s", containerID)
	}

	// Get learning profile
	profile, err := ee.learner.GetProfile(containerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get learning profile: %v", err)
	}

	policy := &GeneratedPolicy{
		ContainerID:    containerID,
		GeneratedAt:    time.Now(),
		BasedOnProfile: profile,
		AutoGenerated:  true,
		Version:        1,
	}

	// Generate syscall policy
	policy.SyscallPolicy = ee.generateSyscallPolicy(profile, state.PahlevanPolicy)

	// Generate network policy
	networkPolicy, err := ee.generateNetworkPolicy(profile, state.PahlevanPolicy)
	if err != nil {
		return nil, fmt.Errorf("failed to generate network policy: %w", err)
	}
	policy.NetworkPolicy = networkPolicy

	// Generate file policy
	filePolicy, err := ee.generateFilePolicy(profile, state.PahlevanPolicy)
	if err != nil {
		return nil, fmt.Errorf("failed to generate file policy: %w", err)
	}
	policy.FilePolicy = filePolicy

	// Calculate policy quality
	policy.Quality = ee.calculatePolicyQuality(policy, profile)
	policy.Confidence = profile.Confidence

	// Update container state
	ee.mu.Lock()
	state.GeneratedPolicy = policy
	state.LastPolicyUpdate = time.Now()
	state.Statistics.PolicyGenerationCount++
	ee.mu.Unlock()

	// Apply policy to eBPF
	if err := ee.applyPolicyToEBPF(containerID, policy); err != nil {
		return nil, fmt.Errorf("failed to apply policy to eBPF: %v", err)
	}

	// Update metrics
	if ee.policyGenerationCounter != nil {
		ee.policyGenerationCounter.Add(context.Background(), 1)
	}

	log.Log.Info("Generated policy for container",
		"containerID", containerID,
		"syscalls", len(policy.SyscallPolicy.AllowedSyscalls),
		"networkRules", len(policy.NetworkPolicy.EgressRules)+len(policy.NetworkPolicy.IngressRules),
		"fileRules", len(policy.FilePolicy.AllowedPaths),
		"quality", policy.Quality.Score)

	return policy, nil
}

func (ee *EnforcementEngine) ProcessViolation(violation *PolicyViolation) error {
	ee.mu.Lock()
	defer ee.mu.Unlock()

	state, exists := ee.containerPolicies[violation.Details.Resource]
	if !exists {
		return fmt.Errorf("container not found for violation: %s", violation.Details.Resource)
	}

	// Record violation
	state.ViolationHistory = append(state.ViolationHistory, *violation)
	state.Statistics.ViolationCount++
	state.Statistics.LastViolationTime = violation.Timestamp

	// Update self-healing state
	if state.SelfHealingState != nil && state.SelfHealingState.Enabled {
		ee.updateSelfHealingState(state, violation)
	}

	// Queue enforcement action
	ee.queueEnforcementAction(&EnforcementAction{
		Type:        ActionTypeViolation,
		ContainerID: violation.Details.Resource,
		Violation:   violation,
		Timestamp:   time.Now(),
		Priority:    ee.violationToPriority(violation.Severity),
	})

	// Update metrics
	if ee.policyViolationCounter != nil {
		ee.policyViolationCounter.Add(context.Background(), 1)
	}

	return nil
}

func (ee *EnforcementEngine) UpdateLifecyclePhase(containerID string, phase WorkloadLifecyclePhase) error {
	ee.mu.Lock()
	defer ee.mu.Unlock()

	state, exists := ee.containerPolicies[containerID]
	if !exists {
		return fmt.Errorf("container not found: %s", containerID)
	}

	oldPhase := state.LifecyclePhase
	state.LifecyclePhase = phase

	// Trigger policy adaptation based on lifecycle changes
	if ee.shouldAdaptPolicyForLifecycle(oldPhase, phase) {
		ee.queueEnforcementAction(&EnforcementAction{
			Type:        ActionTypeUpdatePolicy,
			ContainerID: containerID,
			Timestamp:   time.Now(),
			Priority:    ActionPriorityMedium,
		})
	}

	return nil
}

func (ee *EnforcementEngine) GetPolicyState(containerID string) (*ContainerPolicyState, error) {
	ee.mu.RLock()
	defer ee.mu.RUnlock()

	state, exists := ee.containerPolicies[containerID]
	if !exists {
		return nil, fmt.Errorf("container not found: %s", containerID)
	}

	// Return a copy
	stateCopy := *state
	return &stateCopy, nil
}

func (ee *EnforcementEngine) UnregisterContainer(containerID string) error {
	ee.mu.Lock()
	defer ee.mu.Unlock()

	delete(ee.containerPolicies, containerID)
	return nil
}

// Worker functions

func (ee *EnforcementEngine) enforcementWorker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case <-ee.stopCh:
			return
		case action := <-ee.enforcementQueue:
			ee.processEnforcementAction(action)
		}
	}
}

func (ee *EnforcementEngine) policyGenerationWorker(ctx context.Context) {
	ticker := time.NewTicker(ee.globalConfig.PolicyGenerationInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ee.stopCh:
			return
		case <-ticker.C:
			ee.triggerPeriodicPolicyUpdate()
		}
	}
}

func (ee *EnforcementEngine) selfHealingWorker(ctx context.Context) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ee.stopCh:
			return
		case <-ticker.C:
			ee.processSelfHealingActions()
		}
	}
}

func (ee *EnforcementEngine) statisticsWorker(ctx context.Context) {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ee.stopCh:
			return
		case <-ticker.C:
			ee.updateStatistics()
		}
	}
}

// Helper methods will be implemented in the next part due to length constraints
func (ee *EnforcementEngine) determineEnforcementMode(policy *policyv1alpha1.PahlevanPolicy) EnforcementMode {
	if policy.Spec.EnforcementConfig.Mode == "" {
		return ee.globalConfig.DefaultEnforcementMode
	}
	return EnforcementMode(policy.Spec.EnforcementConfig.Mode)
}

func (ee *EnforcementEngine) queueEnforcementAction(action *EnforcementAction) {
	select {
	case ee.enforcementQueue <- action:
	default:
		log.Log.Error(nil, "Enforcement queue full, dropping action", "type", action.Type, "containerID", action.ContainerID)
	}
}

func (ee *EnforcementEngine) processEnforcementAction(action *EnforcementAction) {
	switch action.Type {
	case ActionTypeGeneratePolicy:
		_, err := ee.GeneratePolicy(action.ContainerID)
		if err != nil {
			log.Log.Error(err, "Failed to generate policy", "containerID", action.ContainerID)
		}
	case ActionTypeUpdatePolicy:
		err := ee.updateExistingPolicy(action.ContainerID)
		if err != nil {
			log.Log.Error(err, "Failed to update policy", "containerID", action.ContainerID)
		}
	case ActionTypeViolation:
		err := ee.handleViolationAction(action)
		if err != nil {
			log.Log.Error(err, "Failed to handle violation", "containerID", action.ContainerID)
		}
	case ActionTypeSelfHeal:
		err := ee.performSelfHealing(action.ContainerID)
		if err != nil {
			log.Log.Error(err, "Failed to perform self-healing", "containerID", action.ContainerID)
		}
	}

	// Update metrics
	if ee.enforcementActionCounter != nil {
		ee.enforcementActionCounter.Add(context.Background(), 1)
	}
}

// Placeholder implementations for complex methods
func (ee *EnforcementEngine) generateSyscallPolicy(profile *learner.LearningProfile, policy *policyv1alpha1.PahlevanPolicy) *SyscallEnforcementPolicy {
	log.Log.Info("Generating syscall policy", "containerID", profile.ContainerID)

	allowedSyscalls := make(map[uint64]*SyscallRule)
	deniedSyscalls := make(map[uint64]*SyscallRule)

	// Add learned syscalls as allowed
	for syscallNr, syscallProfile := range profile.AllowedSyscalls {
		allowedSyscalls[syscallNr] = &SyscallRule{
			SyscallNr:       syscallNr,
			Action:          PolicyActionAllow,
			Conditions:      make([]RuleCondition, 0),
			Criticality:     syscallProfile.Criticality,
			AllowedContexts: make([]string, 0),
		}
	}

	// Add dangerous syscalls to denied list if not learned
	dangerousSyscalls := []uint64{
		101, // ptrace
		165, // mount
		166, // umount
		310, // process_vm_readv
		311, // process_vm_writev
		134, // uselib
		313, // finit_module
	}

	for _, dangerous := range dangerousSyscalls {
		if _, allowed := allowedSyscalls[dangerous]; !allowed {
			deniedSyscalls[dangerous] = &SyscallRule{
				SyscallNr:       dangerous,
				Action:          PolicyActionDeny,
				Conditions:      make([]RuleCondition, 0),
				Criticality:     learner.CriticalityHigh,
				AllowedContexts: make([]string, 0),
			}
		}
	}

	// Override with explicit policy rules if specified
	if policy.Spec.SyscallPolicy != nil {
		for _, allowedSyscall := range policy.Spec.SyscallPolicy.AllowedSyscalls {
			syscallNr := ee.parseSyscallName(allowedSyscall)
			allowedSyscalls[syscallNr] = &SyscallRule{
				SyscallNr:       syscallNr,
				Action:          PolicyActionAllow,
				Conditions:      make([]RuleCondition, 0),
				Criticality:     learner.CriticalityLow,
				AllowedContexts: make([]string, 0),
			}
		}

		for _, deniedSyscall := range policy.Spec.SyscallPolicy.DeniedSyscalls {
			syscallNr := ee.parseSyscallName(deniedSyscall)
			deniedSyscalls[syscallNr] = &SyscallRule{
				SyscallNr:       syscallNr,
				Action:          PolicyActionDeny,
				Conditions:      make([]RuleCondition, 0),
				Criticality:     learner.CriticalityHigh,
				AllowedContexts: make([]string, 0),
			}
		}
	}

	return &SyscallEnforcementPolicy{
		AllowedSyscalls:      allowedSyscalls,
		DeniedSyscalls:       deniedSyscalls,
		DefaultAction:        PolicyActionDeny,
		ContextRules:         make(map[string]*ContextRule),
		ArgumentValidation:   make(map[uint64]*ArgumentRule),
		ReturnCodeValidation: make(map[uint64]*ReturnCodeRule),
	}
}

func (ee *EnforcementEngine) generateNetworkPolicy(profile *learner.LearningProfile, policy *policyv1alpha1.PahlevanPolicy) (*NetworkEnforcementPolicy, error) {
	log.Log.Info("Generating network policy", "containerID", profile.ContainerID)

	var egressRules []*NetworkRule
	var ingressRules []*NetworkRule

	// Generate rules from learned network flows
	for flowKey, flowProfile := range profile.AllowedNetworkFlows {
		if flowProfile.Direction == "outbound" {
			egressRule := &NetworkRule{
				Protocol:  flowProfile.Protocol,
				Direction: "outbound",
				Action:    PolicyActionAllow,
			}
			egressRules = append(egressRules, egressRule)
		} else if flowProfile.Direction == "inbound" {
			ingressRule := &NetworkRule{
				Protocol:  flowProfile.Protocol,
				Direction: "inbound",
				Action:    PolicyActionAllow,
			}
			ingressRules = append(ingressRules, ingressRule)
		}
		_ = flowKey // Avoid unused variable warning
	}

	// Add common allowed egress destinations
	commonEgressRules := []*NetworkRule{
		{
			Protocol:  "tcp",
			Direction: "outbound",
			RemoteEndpoint: &EndpointRule{
				PortRange: &PortRange{Start: 53, End: 53},
			},
			Action:     PolicyActionAllow,
			Conditions: make([]RuleCondition, 0),
		},
		{
			Protocol:  "udp",
			Direction: "outbound",
			RemoteEndpoint: &EndpointRule{
				PortRange: &PortRange{Start: 53, End: 53},
			},
			Action:     PolicyActionAllow,
			Conditions: make([]RuleCondition, 0),
		},
	}
	egressRules = append(egressRules, commonEgressRules...)

	// Override with explicit policy rules if specified
	if policy.Spec.NetworkPolicy != nil {
		// Add explicitly allowed egress rules
		for _, egressRule := range policy.Spec.NetworkPolicy.EgressRules {
			newRule := &NetworkRule{
				Protocol:  egressRule.Protocols[0],
				Direction: "outbound",
				Action:    PolicyActionAllow,
			}
			egressRules = append(egressRules, newRule)
		}

		// Add explicitly allowed ingress rules
		for _, ingressRule := range policy.Spec.NetworkPolicy.IngressRules {
			newRule := &NetworkRule{
				Protocol:  ingressRule.Protocols[0],
				Direction: "inbound",
				Action:    PolicyActionAllow,
			}
			ingressRules = append(ingressRules, newRule)
		}
	}

	return &NetworkEnforcementPolicy{
		EgressRules:          egressRules,
		IngressRules:         ingressRules,
		DefaultEgressAction:  PolicyActionDeny,
		DefaultIngressAction: PolicyActionDeny,
	}, nil
}

func (ee *EnforcementEngine) generateFilePolicy(
	profile *learner.LearningProfile,
	policy *policyv1alpha1.PahlevanPolicy,
) (*FileEnforcementPolicy, error) {
	return &FileEnforcementPolicy{
		AllowedPaths:     make(map[string]*FileRule),
		DeniedPaths:      make(map[string]*FileRule),
		DefaultAction:    PolicyActionDeny,
		PathPatterns:     make([]*PathPattern, 0),
		AccessModeRules:  make(map[string]*AccessModeRule),
		SizeRestrictions: make(map[string]*SizeRestriction),
	}, nil
}

func (ee *EnforcementEngine) calculatePolicyQuality(policy *GeneratedPolicy, profile *learner.LearningProfile) PolicyQuality {
	log.Log.Info("Calculating policy quality", "containerID", policy.ContainerID)

	quality := PolicyQuality{}

	if profile != nil {
		// Calculate completeness based on learning profile coverage
		syscallCoverage := float64(len(policy.SyscallPolicy.AllowedSyscalls)) / float64(len(profile.AllowedSyscalls))
		if syscallCoverage > 1.0 {
			syscallCoverage = 1.0
		}
		quality.Completeness = syscallCoverage

		// Calculate accuracy based on confidence and sample size
		sampleSize := float64(profile.SyscallStatistics.TotalCalls)
		if sampleSize > 1000 {
			quality.Accuracy = 0.95
		} else if sampleSize > 500 {
			quality.Accuracy = 0.85
		} else {
			quality.Accuracy = 0.75
		}

		// Calculate security score based on policy strictness
		strictness := ee.calculatePolicyStrictness(policy)
		quality.Security = 0.5 + (strictness * 0.5) // Higher strictness = better security

		// Performance is inversely related to strictness (more checks = slower)
		quality.Performance = 1.0 - (strictness * 0.3)

		// Maintainability based on policy complexity
		complexity := ee.calculatePolicyComplexity(policy)
		quality.Maintainability = 1.0 - (complexity * 0.4)

		// Overall score is weighted average
		quality.Score = (quality.Completeness * 0.2) +
			(quality.Accuracy * 0.3) +
			(quality.Security * 0.25) +
			(quality.Performance * 0.15) +
			(quality.Maintainability * 0.1)
	} else {
		// Default quality for manually specified policies
		quality.Score = 0.7
		quality.Completeness = 0.8
		quality.Accuracy = 0.75
		quality.Performance = 0.8
		quality.Security = 0.85
		quality.Maintainability = 0.9
	}

	log.Log.Info("Policy quality calculated",
		"score", quality.Score,
		"completeness", quality.Completeness,
		"accuracy", quality.Accuracy,
		"security", quality.Security)

	return quality
}

func (ee *EnforcementEngine) calculatePolicyStrictness(policy *GeneratedPolicy) float64 {
	strictness := 0.5 // Base strictness

	// Syscall policy strictness
	if policy.SyscallPolicy != nil {
		allowedCount := len(policy.SyscallPolicy.AllowedSyscalls)
		if allowedCount < 50 {
			strictness += 0.3 // Very strict
		} else if allowedCount < 100 {
			strictness += 0.1 // Moderately strict
		}

		if policy.SyscallPolicy.DefaultAction == PolicyActionDeny {
			strictness += 0.2
		}
	}

	// Network policy strictness
	if policy.NetworkPolicy != nil {
		if policy.NetworkPolicy.DefaultEgressAction == PolicyActionDeny {
			strictness += 0.1
		}
		if policy.NetworkPolicy.DefaultIngressAction == PolicyActionDeny {
			strictness += 0.1
		}
	}

	// Cap at 1.0
	if strictness > 1.0 {
		strictness = 1.0
	}

	return strictness
}

func (ee *EnforcementEngine) calculatePolicyComplexity(policy *GeneratedPolicy) float64 {
	complexity := 0.0

	// Syscall policy complexity
	if policy.SyscallPolicy != nil {
		complexity += float64(len(policy.SyscallPolicy.AllowedSyscalls)) / 200.0
		complexity += float64(len(policy.SyscallPolicy.DeniedSyscalls)) / 100.0
		complexity += float64(len(policy.SyscallPolicy.ContextRules)) / 50.0
	}

	// Network policy complexity
	if policy.NetworkPolicy != nil {
		complexity += float64(len(policy.NetworkPolicy.EgressRules)) / 20.0
		complexity += float64(len(policy.NetworkPolicy.IngressRules)) / 20.0
	}

	// File policy complexity
	if policy.FilePolicy != nil {
		complexity += float64(len(policy.FilePolicy.AllowedPaths)) / 50.0
		complexity += float64(len(policy.FilePolicy.DeniedPaths)) / 30.0
	}

	// Cap at 1.0
	if complexity > 1.0 {
		complexity = 1.0
	}

	return complexity
}

func (ee *EnforcementEngine) applyPolicyToEBPF(containerID string, policy *GeneratedPolicy) error {
	log.Log.Info("Applying policy to eBPF", "containerID", containerID, "policyVersion", policy.Version)

	if ee.ebpfManager == nil {
		return fmt.Errorf("eBPF manager not available")
	}

	// Convert container ID to uint32 for eBPF
	// This is a simplified conversion - in reality would need proper container ID mapping
	containerIDHash := uint32(0)
	for i, b := range []byte(containerID) {
		if i >= 4 {
			break
		}
		containerIDHash |= uint32(b) << (8 * i)
	}

	// Create eBPF container policy from generated policy
	ebpfPolicy := &ebpf.ContainerPolicy{
		AllowedSyscalls:  make(map[uint64]bool),
		LastUpdate:       time.Now(),
		LearningWindowMs: 300000, // 5 minutes
		EnforcementMode:  0,      // Default to learning mode
		SelfHealing:      true,
	}

	// Convert syscall policy
	if policy.SyscallPolicy != nil {
		for syscall := range policy.SyscallPolicy.AllowedSyscalls {
			ebpfPolicy.AllowedSyscalls[syscall] = true
		}
	}

	// Log network policy conversion (eBPF ContainerPolicy doesn't support complex policies yet)
	if policy.NetworkPolicy != nil {
		log.Log.V(1).Info("Network policy configured",
			"egressRules", len(policy.NetworkPolicy.EgressRules),
			"ingressRules", len(policy.NetworkPolicy.IngressRules))
	}

	// Log file policy conversion
	if policy.FilePolicy != nil {
		log.Log.V(1).Info("File policy configured",
			"allowedPaths", len(policy.FilePolicy.AllowedPaths),
			"deniedPaths", len(policy.FilePolicy.DeniedPaths))
	}

	// Apply the policy to eBPF
	return ee.ebpfManager.UpdateContainerPolicy(containerID, ebpfPolicy)
}

func (ee *EnforcementEngine) updateSelfHealingState(state *ContainerPolicyState, violation *PolicyViolation) {
	if state.SelfHealingState == nil {
		return
	}

	state.SelfHealingState.ViolationCount++
	state.SelfHealingState.LastViolationTime = violation.Timestamp

	// Check if we need to trigger self-healing
	if state.SelfHealingState.ViolationCount >= state.SelfHealingState.RollbackThreshold {
		if time.Since(state.SelfHealingState.LastViolationTime) <= state.SelfHealingState.RollbackWindow {
			ee.queueEnforcementAction(&EnforcementAction{
				Type:        ActionTypeSelfHeal,
				ContainerID: state.ContainerID,
				Timestamp:   time.Now(),
				Priority:    ActionPriorityHigh,
			})
		}
	}
}

func (ee *EnforcementEngine) violationToPriority(severity ViolationSeverity) ActionPriority {
	switch severity {
	case ViolationSeverityCritical:
		return ActionPriorityCritical
	case ViolationSeverityHigh:
		return ActionPriorityHigh
	case ViolationSeverityMedium:
		return ActionPriorityMedium
	default:
		return ActionPriorityLow
	}
}

func (ee *EnforcementEngine) shouldAdaptPolicyForLifecycle(oldPhase, newPhase WorkloadLifecyclePhase) bool {
	// Adapt policy when transitioning from starting to running, or running to steady
	return (oldPhase == PhaseStarting && newPhase == PhaseRunning) ||
		(oldPhase == PhaseRunning && newPhase == PhaseSteady)
}

func (ee *EnforcementEngine) triggerPeriodicPolicyUpdate() {
	log.Log.Info("Triggering periodic policy updates")

	ee.mu.RLock()
	containerStates := make(map[string]*ContainerPolicyState)
	for k, v := range ee.containerPolicies {
		containerStates[k] = v
	}
	ee.mu.RUnlock()

	for containerID, state := range containerStates {
		// Check if policy needs updating (older than 1 hour)
		if time.Since(state.LastPolicyUpdate) > time.Hour {
			// Get latest learning profile
			if profile, err := ee.learner.GetProfile(containerID); err == nil && profile != nil {
				ee.queueEnforcementAction(&EnforcementAction{
					Type:        ActionTypeGeneratePolicy,
					ContainerID: containerID,
					Priority:    ActionPriorityMedium,
					Timestamp:   time.Now(),
				})
			}
		}
	}
}

func (ee *EnforcementEngine) processSelfHealingActions() {
	log.Log.Info("Processing self-healing actions")

	ee.mu.RLock()
	containerStates := make(map[string]*ContainerPolicyState)
	for k, v := range ee.containerPolicies {
		if v.SelfHealingState != nil && v.SelfHealingState.Enabled {
			containerStates[k] = v
		}
	}
	ee.mu.RUnlock()

	for containerID, state := range containerStates {
		if ee.shouldTriggerSelfHealing(state) {
			ee.queueEnforcementAction(&EnforcementAction{
				Type:        ActionTypeSelfHeal,
				ContainerID: containerID,
				Priority:    ActionPriorityHigh,
				Timestamp:   time.Now(),
			})
		}
	}
}

func (ee *EnforcementEngine) shouldTriggerSelfHealing(state *ContainerPolicyState) bool {
	if state.SelfHealingState == nil {
		return false
	}

	// Trigger self-healing if there have been multiple violations recently
	recentViolations := 0
	cutoff := time.Now().Add(-10 * time.Minute)
	for _, violation := range state.ViolationHistory {
		if violation.Timestamp.After(cutoff) {
			recentViolations++
		}
	}

	// Trigger if more than 5 violations in the last 10 minutes
	return recentViolations > 5
}

func (ee *EnforcementEngine) updateStatistics() {
	log.Log.Info("Updating enforcement statistics")

	ee.mu.Lock()
	defer ee.mu.Unlock()

	var totalViolations int64
	var totalPolicies int64
	var activePolicies int64

	for _, state := range ee.containerPolicies {
		totalPolicies++
		if state.GeneratedPolicy != nil {
			activePolicies++
		}
		totalViolations += int64(len(state.ViolationHistory))

		// Update individual container statistics
		state.Statistics.LastViolationTime = time.Now()
		state.Statistics.ViolationCount = int64(len(state.ViolationHistory))
	}

	// Update metrics
	if ee.policyViolationCounter != nil {
		ee.policyViolationCounter.Add(context.Background(), totalViolations)
	}

	log.Log.Info("Statistics updated",
		"totalPolicies", totalPolicies,
		"activePolicies", activePolicies,
		"totalViolations", totalViolations)
}

func (ee *EnforcementEngine) updateExistingPolicy(containerID string) error {
	log.Log.Info("Updating existing policy", "containerID", containerID)

	ee.mu.RLock()
	state, exists := ee.containerPolicies[containerID]
	ee.mu.RUnlock()

	if !exists {
		return fmt.Errorf("container %s not found", containerID)
	}

	// Get updated learning profile
	_, err := ee.learner.GetProfile(containerID)
	if err != nil {
		return fmt.Errorf("failed to get learning profile: %v", err)
	}

	// Generate new policy based on updated profile
	newPolicy, err := ee.GeneratePolicy(containerID)
	if err != nil {
		return fmt.Errorf("failed to generate updated policy: %v", err)
	}

	// Apply the updated policy
	if err := ee.applyPolicyToEBPF(containerID, newPolicy); err != nil {
		return fmt.Errorf("failed to apply updated policy: %v", err)
	}

	ee.mu.Lock()
	state.GeneratedPolicy = newPolicy
	state.LastPolicyUpdate = time.Now()
	state.Statistics.PolicyGenerationCount++
	ee.mu.Unlock()

	log.Log.Info("Policy updated successfully", "containerID", containerID, "version", newPolicy.Version)
	return nil
}

func (ee *EnforcementEngine) handleViolationAction(action *EnforcementAction) error {
	log.Log.Info("Handling violation action", "containerID", action.ContainerID, "type", action.Type)

	if action.Violation == nil {
		return fmt.Errorf("violation action missing violation data")
	}

	ee.mu.Lock()
	state, exists := ee.containerPolicies[action.ContainerID]
	if !exists {
		ee.mu.Unlock()
		return fmt.Errorf("container %s not found", action.ContainerID)
	}

	// Add violation to history
	state.ViolationHistory = append(state.ViolationHistory, *action.Violation)

	// Limit violation history size
	if len(state.ViolationHistory) > 100 {
		state.ViolationHistory = state.ViolationHistory[len(state.ViolationHistory)-100:]
	}

	// Update statistics
	state.Statistics.ViolationCount = int64(len(state.ViolationHistory))
	state.Statistics.LastViolationTime = action.Violation.Timestamp

	// Update self-healing state
	ee.updateSelfHealingState(state, action.Violation)
	ee.mu.Unlock()

	// Determine response action based on violation severity
	switch action.Violation.Severity {
	case ViolationSeverityCritical:
		// For critical violations, consider adaptive policy tightening
		return ee.handleCriticalViolation(action.ContainerID, action.Violation)
	case ViolationSeverityHigh:
		// For high severity, increase monitoring
		return ee.increaseMonitoring(action.ContainerID)
	default:
		// For lower severity, just log and continue
		log.Log.Info("Violation recorded", "containerID", action.ContainerID, "severity", action.Violation.Severity)
	}

	return nil
}

func (ee *EnforcementEngine) handleCriticalViolation(containerID string, violation *PolicyViolation) error {
	log.Log.Info("Handling critical violation", "containerID", containerID, "type", violation.ViolationType)

	// Check if we should adapt the policy
	ee.mu.RLock()
	state, exists := ee.containerPolicies[containerID]
	ee.mu.RUnlock()

	if !exists {
		return fmt.Errorf("container %s not found", containerID)
	}

	// Count recent critical violations
	recentCritical := 0
	cutoff := time.Now().Add(-5 * time.Minute)
	for _, v := range state.ViolationHistory {
		if v.Timestamp.After(cutoff) && v.Severity == ViolationSeverityCritical {
			recentCritical++
		}
	}

	// If multiple critical violations, tighten policy
	if recentCritical >= 3 {
		log.Log.Info("Multiple critical violations detected, tightening policy", "containerID", containerID)
		return ee.tightenPolicy(containerID, violation)
	}

	return nil
}

func (ee *EnforcementEngine) tightenPolicy(containerID string, violation *PolicyViolation) error {
	ee.mu.RLock()
	state, exists := ee.containerPolicies[containerID]
	ee.mu.RUnlock()

	if !exists || state.GeneratedPolicy == nil {
		return fmt.Errorf("no policy to tighten for container %s", containerID)
	}

	// Create a tightened version of the policy
	tightenedPolicy := ee.createTightenedPolicy(state.GeneratedPolicy, violation)

	// Apply the tightened policy
	if err := ee.applyPolicyToEBPF(containerID, tightenedPolicy); err != nil {
		return fmt.Errorf("failed to apply tightened policy: %v", err)
	}

	// Update container state
	ee.mu.Lock()
	state.GeneratedPolicy = tightenedPolicy
	state.LastPolicyUpdate = time.Now()
	state.Statistics.SelfHealingActionCount++
	ee.mu.Unlock()

	log.Log.Info("Policy tightened successfully", "containerID", containerID)
	return nil
}

func (ee *EnforcementEngine) createTightenedPolicy(original *GeneratedPolicy, violation *PolicyViolation) *GeneratedPolicy {
	tightened := &GeneratedPolicy{
		ContainerID:    original.ContainerID,
		GeneratedAt:    time.Now(),
		BasedOnProfile: original.BasedOnProfile,
		AutoGenerated:  true,
		Version:        original.Version + 1,
		Confidence:     original.Confidence * 0.9, // Reduce confidence after tightening
	}

	// Copy and tighten syscall policy
	if original.SyscallPolicy != nil {
		tightened.SyscallPolicy = &SyscallEnforcementPolicy{
			AllowedSyscalls:      make(map[uint64]*SyscallRule),
			DeniedSyscalls:       make(map[uint64]*SyscallRule),
			DefaultAction:        PolicyActionDeny, // More restrictive default
			ContextRules:         make(map[string]*ContextRule),
			ArgumentValidation:   make(map[uint64]*ArgumentRule),
			ReturnCodeValidation: make(map[uint64]*ReturnCodeRule),
		}

		// Copy allowed syscalls, potentially removing the violating one
		for syscall, rule := range original.SyscallPolicy.AllowedSyscalls {
			if violation.ViolationType == ViolationTypeSyscall {
				// Remove or restrict the violating syscall
				continue
			}
			tightened.SyscallPolicy.AllowedSyscalls[syscall] = rule
		}

		// Copy denied syscalls and add the violating one if applicable
		for syscall, rule := range original.SyscallPolicy.DeniedSyscalls {
			tightened.SyscallPolicy.DeniedSyscalls[syscall] = rule
		}

		if violation.ViolationType == ViolationTypeSyscall {
			// Parse syscall number from resource if available
			syscallNr := uint64(999) // Default to unknown syscall
			tightened.SyscallPolicy.DeniedSyscalls[syscallNr] = &SyscallRule{
				SyscallNr: syscallNr,
				Action:    PolicyActionDeny,
			}
		}
	}

	// Copy network policy (potentially tighten based on violation type)
	if original.NetworkPolicy != nil {
		tightened.NetworkPolicy = &NetworkEnforcementPolicy{
			EgressRules:          original.NetworkPolicy.EgressRules,
			IngressRules:         original.NetworkPolicy.IngressRules,
			DefaultEgressAction:  PolicyActionDeny, // More restrictive
			DefaultIngressAction: PolicyActionDeny, // More restrictive
		}
	}

	// Copy file policy
	if original.FilePolicy != nil {
		tightened.FilePolicy = original.FilePolicy // Simple copy for now
	}

	return tightened
}

func (ee *EnforcementEngine) increaseMonitoring(containerID string) error {
	log.Log.Info("Increasing monitoring for container", "containerID", containerID)

	// This would typically involve:
	// 1. Increasing eBPF sampling rate
	// 2. Enabling additional monitoring features
	// 3. Setting up alerting for future violations

	// For now, just update statistics
	ee.mu.Lock()
	if state, exists := ee.containerPolicies[containerID]; exists {
		state.Statistics.EnforcementActionCount++
	}
	ee.mu.Unlock()

	return nil
}

func (ee *EnforcementEngine) performSelfHealing(containerID string) error {
	log.Log.Info("Performing self-healing", "containerID", containerID)

	ee.mu.RLock()
	state, exists := ee.containerPolicies[containerID]
	ee.mu.RUnlock()

	if !exists {
		return fmt.Errorf("container %s not found", containerID)
	}

	if state.SelfHealingState == nil || !state.SelfHealingState.Enabled {
		return fmt.Errorf("self-healing not enabled for container %s", containerID)
	}

	// Analyze recent violations to determine healing strategy
	strategy := ee.determineSelfHealingStrategy(state)

	switch strategy {
	case "regenerate_policy":
		return ee.regeneratePolicy(containerID)
	case "adjust_thresholds":
		return ee.adjustPolicyThresholds(containerID)
	case "rollback_policy":
		return ee.rollbackPolicy(containerID)
	default:
		log.Log.Info("No self-healing action needed", "containerID", containerID)
	}

	return nil
}

func (ee *EnforcementEngine) determineSelfHealingStrategy(state *ContainerPolicyState) string {
	// Simple strategy determination based on violation patterns
	if len(state.ViolationHistory) > 10 {
		return "regenerate_policy"
	} else if len(state.ViolationHistory) > 5 {
		return "adjust_thresholds"
	}
	return "none"
}

func (ee *EnforcementEngine) regeneratePolicy(containerID string) error {
	log.Log.Info("Regenerating policy for self-healing", "containerID", containerID)
	return ee.updateExistingPolicy(containerID)
}

func (ee *EnforcementEngine) adjustPolicyThresholds(containerID string) error {
	log.Log.Info("Adjusting policy thresholds for self-healing", "containerID", containerID)

	ee.mu.Lock()
	state, exists := ee.containerPolicies[containerID]
	if exists && state.GeneratedPolicy != nil {
		// Make policy slightly more permissive
		state.GeneratedPolicy.Confidence *= 0.95
		state.Statistics.SelfHealingActionCount++
	}
	ee.mu.Unlock()

	return nil
}

func (ee *EnforcementEngine) rollbackPolicy(containerID string) error {
	log.Log.Info("Rolling back policy for self-healing", "containerID", containerID)

	// This would typically restore a previous known-good policy version
	// For now, just mark that a rollback occurred
	ee.mu.Lock()
	if state, exists := ee.containerPolicies[containerID]; exists {
		state.Statistics.SelfHealingActionCount++
		state.Statistics.SelfHealingActionCount++
	}
	ee.mu.Unlock()

	return nil
}

// Helper method to parse syscall names (can be names or numbers)
func (ee *EnforcementEngine) parseSyscallName(syscallName string) uint64 {
	// Basic implementation - would use a proper syscall name-to-number mapping
	// For now, we'll try to parse as number or return a hash

	// Try parsing as a number first
	if val, err := strconv.ParseUint(syscallName, 10, 64); err == nil {
		return val
	}

	// If not a number, use a simple hash based on the name
	// In a real implementation, this would use proper syscall name resolution
	h := fnv.New64()
	h.Write([]byte(syscallName))
	return h.Sum64() % 1000 // Keep it in a reasonable range
}
